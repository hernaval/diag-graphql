# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateArticle {
  count: ArticleCountAggregate
  max: ArticleMaxAggregate
  min: ArticleMinAggregate
}

type AggregateUser {
  count: UserCountAggregate
  max: UserMaxAggregate
  min: UserMinAggregate
}

type Article {
  author: String!
  createdDate: DateTime
  id: String!
  imageUrl: String!
  text: String!
  title: String!
  updatedDate: DateTime!
}

type ArticleCountAggregate {
  _all: Int!
  author: Int
  createdDate: Int
  id: Int
  imageUrl: Int
  text: Int
  title: Int
  updatedDate: Int
}

input ArticleCreateInput {
  Users: UserSaveArticleCreateNestedManyWithoutArticleInput
  author: String!
  createdDate: DateTime
  id: String
  imageUrl: String!
  text: String!
  title: String!
  updatedDate: DateTime
}

input ArticleCreateNestedOneWithoutUsersInput {
  connect: ArticleWhereUniqueInput
  connectOrCreate: ArticleCreateOrConnectWithoutUsersInput
  create: ArticleCreateWithoutUsersInput
}

input ArticleCreateOrConnectWithoutUsersInput {
  create: ArticleCreateWithoutUsersInput!
  where: ArticleWhereUniqueInput!
}

input ArticleCreateWithoutUsersInput {
  author: String!
  createdDate: DateTime
  id: String
  imageUrl: String!
  text: String!
  title: String!
  updatedDate: DateTime
}

type ArticleMaxAggregate {
  author: String
  createdDate: DateTime
  id: String
  imageUrl: String
  text: String
  title: String
  updatedDate: DateTime
}

type ArticleMinAggregate {
  author: String
  createdDate: DateTime
  id: String
  imageUrl: String
  text: String
  title: String
  updatedDate: DateTime
}

input ArticleOrderByInput {
  author: SortOrder
  createdDate: SortOrder
  id: SortOrder
  imageUrl: SortOrder
  text: SortOrder
  title: SortOrder
  updatedDate: SortOrder
}

input ArticleRelationFilter {
  is: ArticleWhereInput
  isNot: ArticleWhereInput
}

enum ArticleScalarFieldEnum {
  author
  createdDate
  id
  imageUrl
  text
  title
  updatedDate
}

input ArticleUpdateInput {
  Users: UserSaveArticleUpdateManyWithoutArticleInput
  author: StringFieldUpdateOperationsInput
  createdDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  imageUrl: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedDate: DateTimeFieldUpdateOperationsInput
}

input ArticleUpdateManyMutationInput {
  author: StringFieldUpdateOperationsInput
  createdDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  imageUrl: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedDate: DateTimeFieldUpdateOperationsInput
}

input ArticleUpdateOneRequiredWithoutUsersInput {
  connect: ArticleWhereUniqueInput
  connectOrCreate: ArticleCreateOrConnectWithoutUsersInput
  create: ArticleCreateWithoutUsersInput
  update: ArticleUpdateWithoutUsersInput
  upsert: ArticleUpsertWithoutUsersInput
}

input ArticleUpdateWithoutUsersInput {
  author: StringFieldUpdateOperationsInput
  createdDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  imageUrl: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedDate: DateTimeFieldUpdateOperationsInput
}

input ArticleUpsertWithoutUsersInput {
  create: ArticleCreateWithoutUsersInput!
  update: ArticleUpdateWithoutUsersInput!
}

input ArticleWhereInput {
  AND: [ArticleWhereInput!]
  NOT: [ArticleWhereInput!]
  OR: [ArticleWhereInput!]
  Users: UserSaveArticleListRelationFilter
  author: StringFilter
  createdDate: DateTimeNullableFilter
  id: StringFilter
  imageUrl: StringFilter
  text: StringFilter
  title: StringFilter
  updatedDate: DateTimeFilter
}

input ArticleWhereUniqueInput {
  id: String
}

input BoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

type ForgotPasswordType {
  error: String
  success: Boolean
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type LoginClientType {
  error: String
  token: String
}

type LoginType {
  token: String
}

type Mutation {
  createArticle(data: ArticleCreateInput!): Article!
  createUser(data: UserCreateInput!): User!
  deleteArticle(where: ArticleWhereUniqueInput!): Article
  deleteManyArticle(where: ArticleWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteUser(where: UserWhereUniqueInput!): User
  resetClientPassword(data: UserUpdateInput!): ForgotPasswordType!
  signupClient(data: UserCreateInput!): SignupClientType!
  updateArticle(data: ArticleUpdateInput!, where: ArticleWhereUniqueInput!): Article
  updateManyArticle(data: ArticleUpdateManyMutationInput!, where: ArticleWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertArticle(create: ArticleCreateInput!, update: ArticleUpdateInput!, where: ArticleWhereUniqueInput!): Article!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableBoolFieldUpdateOperationsInput {
  set: Boolean
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateArticle(cursor: ArticleWhereUniqueInput, orderBy: [ArticleOrderByInput!], skip: Int, take: Int, where: ArticleWhereInput): AggregateArticle!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  article(where: ArticleWhereUniqueInput!): Article
  articles(cursor: ArticleWhereUniqueInput, distinct: [ArticleScalarFieldEnum!], orderBy: [ArticleOrderByInput!], skip: Int, take: Int, where: ArticleWhereInput): [Article!]!
  findFirstArticle(cursor: ArticleWhereUniqueInput, distinct: [ArticleScalarFieldEnum!], orderBy: [ArticleOrderByInput!], skip: Int, take: Int, where: ArticleWhereInput): Article
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): User
  loginAdmin(email: String!, password: String!): LoginType
  loginUser(email: String!, password: String!): LoginClientType
  sendResetPasswordLink(where: UserWhereUniqueInput!): ForgotPasswordType!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  verifyTokenBeforeReset(email: String!, token: String!): ForgotPasswordType!
}

enum QueryMode {
  default
  insensitive
}

type SignupClientType {
  error: String
  user: User
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input SurveyCreateNestedManyWithoutUserInput {
  connect: [SurveyWhereUniqueInput!]
  connectOrCreate: [SurveyCreateOrConnectWithoutUserInput!]
  create: [SurveyCreateWithoutUserInput!]
}

input SurveyCreateOrConnectWithoutUserInput {
  create: SurveyCreateWithoutUserInput!
  where: SurveyWhereUniqueInput!
}

input SurveyCreateWithoutUserInput {
  createdDate: DateTime
  id: String
  updatedDate: DateTime
  value: Int!
}

input SurveyListRelationFilter {
  every: SurveyWhereInput
  none: SurveyWhereInput
  some: SurveyWhereInput
}

input SurveyScalarWhereInput {
  AND: [SurveyScalarWhereInput!]
  NOT: [SurveyScalarWhereInput!]
  OR: [SurveyScalarWhereInput!]
  createdDate: DateTimeNullableFilter
  id: StringFilter
  updatedDate: DateTimeNullableFilter
  userId: StringFilter
  value: IntFilter
}

input SurveyUpdateManyMutationInput {
  createdDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  updatedDate: NullableDateTimeFieldUpdateOperationsInput
  value: IntFieldUpdateOperationsInput
}

input SurveyUpdateManyWithWhereWithoutUserInput {
  data: SurveyUpdateManyMutationInput!
  where: SurveyScalarWhereInput!
}

input SurveyUpdateManyWithoutUserInput {
  connect: [SurveyWhereUniqueInput!]
  connectOrCreate: [SurveyCreateOrConnectWithoutUserInput!]
  create: [SurveyCreateWithoutUserInput!]
  delete: [SurveyWhereUniqueInput!]
  deleteMany: [SurveyScalarWhereInput!]
  disconnect: [SurveyWhereUniqueInput!]
  set: [SurveyWhereUniqueInput!]
  update: [SurveyUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [SurveyUpdateManyWithWhereWithoutUserInput!]
  upsert: [SurveyUpsertWithWhereUniqueWithoutUserInput!]
}

input SurveyUpdateWithWhereUniqueWithoutUserInput {
  data: SurveyUpdateWithoutUserInput!
  where: SurveyWhereUniqueInput!
}

input SurveyUpdateWithoutUserInput {
  createdDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  updatedDate: NullableDateTimeFieldUpdateOperationsInput
  value: IntFieldUpdateOperationsInput
}

input SurveyUpsertWithWhereUniqueWithoutUserInput {
  create: SurveyCreateWithoutUserInput!
  update: SurveyUpdateWithoutUserInput!
  where: SurveyWhereUniqueInput!
}

input SurveyWhereInput {
  AND: [SurveyWhereInput!]
  NOT: [SurveyWhereInput!]
  OR: [SurveyWhereInput!]
  User: UserRelationFilter
  createdDate: DateTimeNullableFilter
  id: StringFilter
  updatedDate: DateTimeNullableFilter
  userId: StringFilter
  value: IntFilter
}

input SurveyWhereUniqueInput {
  id: String
}

type User {
  activity: String!
  category: String!
  companySize: String!
  country: String!
  createdDate: DateTime
  email: String!
  emailConfirmed: Boolean
  firstName: String!
  forgotToken: String
  function: String!
  gender: String!
  id: String!
  lastName: String!
  organisation: String!
  passwordHash: String!
  phone: String!
  role: String
  status: String
  updatedDate: DateTime
  username: String
}

type UserCountAggregate {
  _all: Int!
  activity: Int
  category: Int
  companySize: Int
  country: Int
  createdDate: Int
  email: Int
  emailConfirmed: Int
  firstName: Int
  forgotToken: Int
  function: Int
  gender: Int
  id: Int
  lastName: Int
  organisation: Int
  passwordHash: Int
  phone: Int
  role: Int
  status: Int
  updatedDate: Int
  username: Int
}

input UserCreateInput {
  Articles: UserSaveArticleCreateNestedManyWithoutUserInput
  Surveys: SurveyCreateNestedManyWithoutUserInput
  activity: String!
  category: String!
  companySize: String!
  country: String!
  createdDate: DateTime
  email: String!
  emailConfirmed: Boolean
  firstName: String!
  forgotToken: String
  function: String!
  gender: String!
  id: String
  lastName: String!
  organisation: String!
  passwordHash: String!
  phone: String!
  role: String
  status: String
  updatedDate: DateTime
  username: String
}

input UserCreateNestedOneWithoutArticlesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutArticlesInput
  create: UserCreateWithoutArticlesInput
}

input UserCreateOrConnectWithoutArticlesInput {
  create: UserCreateWithoutArticlesInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutArticlesInput {
  Surveys: SurveyCreateNestedManyWithoutUserInput
  activity: String!
  category: String!
  companySize: String!
  country: String!
  createdDate: DateTime
  email: String!
  emailConfirmed: Boolean
  firstName: String!
  forgotToken: String
  function: String!
  gender: String!
  id: String
  lastName: String!
  organisation: String!
  passwordHash: String!
  phone: String!
  role: String
  status: String
  updatedDate: DateTime
  username: String
}

type UserMaxAggregate {
  activity: String
  category: String
  companySize: String
  country: String
  createdDate: DateTime
  email: String
  emailConfirmed: Boolean
  firstName: String
  forgotToken: String
  function: String
  gender: String
  id: String
  lastName: String
  organisation: String
  passwordHash: String
  phone: String
  role: String
  status: String
  updatedDate: DateTime
  username: String
}

type UserMinAggregate {
  activity: String
  category: String
  companySize: String
  country: String
  createdDate: DateTime
  email: String
  emailConfirmed: Boolean
  firstName: String
  forgotToken: String
  function: String
  gender: String
  id: String
  lastName: String
  organisation: String
  passwordHash: String
  phone: String
  role: String
  status: String
  updatedDate: DateTime
  username: String
}

input UserOrderByInput {
  activity: SortOrder
  category: SortOrder
  companySize: SortOrder
  country: SortOrder
  createdDate: SortOrder
  email: SortOrder
  emailConfirmed: SortOrder
  firstName: SortOrder
  forgotToken: SortOrder
  function: SortOrder
  gender: SortOrder
  id: SortOrder
  lastName: SortOrder
  organisation: SortOrder
  passwordHash: SortOrder
  phone: SortOrder
  role: SortOrder
  status: SortOrder
  updatedDate: SortOrder
  username: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserSaveArticleCreateNestedManyWithoutArticleInput {
  connect: [UserSaveArticleWhereUniqueInput!]
  connectOrCreate: [UserSaveArticleCreateOrConnectWithoutArticleInput!]
  create: [UserSaveArticleCreateWithoutArticleInput!]
}

input UserSaveArticleCreateNestedManyWithoutUserInput {
  connect: [UserSaveArticleWhereUniqueInput!]
  connectOrCreate: [UserSaveArticleCreateOrConnectWithoutUserInput!]
  create: [UserSaveArticleCreateWithoutUserInput!]
}

input UserSaveArticleCreateOrConnectWithoutArticleInput {
  create: UserSaveArticleCreateWithoutArticleInput!
  where: UserSaveArticleWhereUniqueInput!
}

input UserSaveArticleCreateOrConnectWithoutUserInput {
  create: UserSaveArticleCreateWithoutUserInput!
  where: UserSaveArticleWhereUniqueInput!
}

input UserSaveArticleCreateWithoutArticleInput {
  User: UserCreateNestedOneWithoutArticlesInput!
  dateSaved: DateTime
}

input UserSaveArticleCreateWithoutUserInput {
  Article: ArticleCreateNestedOneWithoutUsersInput!
  dateSaved: DateTime
}

input UserSaveArticleListRelationFilter {
  every: UserSaveArticleWhereInput
  none: UserSaveArticleWhereInput
  some: UserSaveArticleWhereInput
}

input UserSaveArticleScalarWhereInput {
  AND: [UserSaveArticleScalarWhereInput!]
  NOT: [UserSaveArticleScalarWhereInput!]
  OR: [UserSaveArticleScalarWhereInput!]
  articleId: StringFilter
  dateSaved: DateTimeNullableFilter
  userId: StringFilter
}

input UserSaveArticleUpdateManyMutationInput {
  dateSaved: NullableDateTimeFieldUpdateOperationsInput
}

input UserSaveArticleUpdateManyWithWhereWithoutArticleInput {
  data: UserSaveArticleUpdateManyMutationInput!
  where: UserSaveArticleScalarWhereInput!
}

input UserSaveArticleUpdateManyWithWhereWithoutUserInput {
  data: UserSaveArticleUpdateManyMutationInput!
  where: UserSaveArticleScalarWhereInput!
}

input UserSaveArticleUpdateManyWithoutArticleInput {
  connect: [UserSaveArticleWhereUniqueInput!]
  connectOrCreate: [UserSaveArticleCreateOrConnectWithoutArticleInput!]
  create: [UserSaveArticleCreateWithoutArticleInput!]
  delete: [UserSaveArticleWhereUniqueInput!]
  deleteMany: [UserSaveArticleScalarWhereInput!]
  disconnect: [UserSaveArticleWhereUniqueInput!]
  set: [UserSaveArticleWhereUniqueInput!]
  update: [UserSaveArticleUpdateWithWhereUniqueWithoutArticleInput!]
  updateMany: [UserSaveArticleUpdateManyWithWhereWithoutArticleInput!]
  upsert: [UserSaveArticleUpsertWithWhereUniqueWithoutArticleInput!]
}

input UserSaveArticleUpdateManyWithoutUserInput {
  connect: [UserSaveArticleWhereUniqueInput!]
  connectOrCreate: [UserSaveArticleCreateOrConnectWithoutUserInput!]
  create: [UserSaveArticleCreateWithoutUserInput!]
  delete: [UserSaveArticleWhereUniqueInput!]
  deleteMany: [UserSaveArticleScalarWhereInput!]
  disconnect: [UserSaveArticleWhereUniqueInput!]
  set: [UserSaveArticleWhereUniqueInput!]
  update: [UserSaveArticleUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [UserSaveArticleUpdateManyWithWhereWithoutUserInput!]
  upsert: [UserSaveArticleUpsertWithWhereUniqueWithoutUserInput!]
}

input UserSaveArticleUpdateWithWhereUniqueWithoutArticleInput {
  data: UserSaveArticleUpdateWithoutArticleInput!
  where: UserSaveArticleWhereUniqueInput!
}

input UserSaveArticleUpdateWithWhereUniqueWithoutUserInput {
  data: UserSaveArticleUpdateWithoutUserInput!
  where: UserSaveArticleWhereUniqueInput!
}

input UserSaveArticleUpdateWithoutArticleInput {
  User: UserUpdateOneRequiredWithoutArticlesInput
  dateSaved: NullableDateTimeFieldUpdateOperationsInput
}

input UserSaveArticleUpdateWithoutUserInput {
  Article: ArticleUpdateOneRequiredWithoutUsersInput
  dateSaved: NullableDateTimeFieldUpdateOperationsInput
}

input UserSaveArticleUpsertWithWhereUniqueWithoutArticleInput {
  create: UserSaveArticleCreateWithoutArticleInput!
  update: UserSaveArticleUpdateWithoutArticleInput!
  where: UserSaveArticleWhereUniqueInput!
}

input UserSaveArticleUpsertWithWhereUniqueWithoutUserInput {
  create: UserSaveArticleCreateWithoutUserInput!
  update: UserSaveArticleUpdateWithoutUserInput!
  where: UserSaveArticleWhereUniqueInput!
}

input UserSaveArticleUserIdArticleIdCompoundUniqueInput {
  articleId: String!
  userId: String!
}

input UserSaveArticleWhereInput {
  AND: [UserSaveArticleWhereInput!]
  Article: ArticleRelationFilter
  NOT: [UserSaveArticleWhereInput!]
  OR: [UserSaveArticleWhereInput!]
  User: UserRelationFilter
  articleId: StringFilter
  dateSaved: DateTimeNullableFilter
  userId: StringFilter
}

input UserSaveArticleWhereUniqueInput {
  userId_articleId: UserSaveArticleUserIdArticleIdCompoundUniqueInput
}

enum UserScalarFieldEnum {
  activity
  category
  companySize
  country
  createdDate
  email
  emailConfirmed
  firstName
  forgotToken
  function
  gender
  id
  lastName
  organisation
  passwordHash
  phone
  role
  status
  updatedDate
  username
}

input UserUpdateInput {
  Articles: UserSaveArticleUpdateManyWithoutUserInput
  Surveys: SurveyUpdateManyWithoutUserInput
  activity: StringFieldUpdateOperationsInput
  category: StringFieldUpdateOperationsInput
  companySize: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  createdDate: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailConfirmed: NullableBoolFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  forgotToken: NullableStringFieldUpdateOperationsInput
  function: StringFieldUpdateOperationsInput
  gender: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  organisation: StringFieldUpdateOperationsInput
  passwordHash: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  role: NullableStringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  updatedDate: NullableDateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  activity: StringFieldUpdateOperationsInput
  category: StringFieldUpdateOperationsInput
  companySize: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  createdDate: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailConfirmed: NullableBoolFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  forgotToken: NullableStringFieldUpdateOperationsInput
  function: StringFieldUpdateOperationsInput
  gender: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  organisation: StringFieldUpdateOperationsInput
  passwordHash: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  role: NullableStringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  updatedDate: NullableDateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutArticlesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutArticlesInput
  create: UserCreateWithoutArticlesInput
  update: UserUpdateWithoutArticlesInput
  upsert: UserUpsertWithoutArticlesInput
}

input UserUpdateWithoutArticlesInput {
  Surveys: SurveyUpdateManyWithoutUserInput
  activity: StringFieldUpdateOperationsInput
  category: StringFieldUpdateOperationsInput
  companySize: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  createdDate: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailConfirmed: NullableBoolFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  forgotToken: NullableStringFieldUpdateOperationsInput
  function: StringFieldUpdateOperationsInput
  gender: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  organisation: StringFieldUpdateOperationsInput
  passwordHash: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  role: NullableStringFieldUpdateOperationsInput
  status: NullableStringFieldUpdateOperationsInput
  updatedDate: NullableDateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpsertWithoutArticlesInput {
  create: UserCreateWithoutArticlesInput!
  update: UserUpdateWithoutArticlesInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  Articles: UserSaveArticleListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  Surveys: SurveyListRelationFilter
  activity: StringFilter
  category: StringFilter
  companySize: StringFilter
  country: StringFilter
  createdDate: DateTimeNullableFilter
  email: StringFilter
  emailConfirmed: BoolNullableFilter
  firstName: StringFilter
  forgotToken: StringNullableFilter
  function: StringFilter
  gender: StringFilter
  id: StringFilter
  lastName: StringFilter
  organisation: StringFilter
  passwordHash: StringFilter
  phone: StringFilter
  role: StringNullableFilter
  status: StringNullableFilter
  updatedDate: DateTimeNullableFilter
  username: StringNullableFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}
